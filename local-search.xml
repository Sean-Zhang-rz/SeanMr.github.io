<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端算法救赎———面试必会二分查找</title>
    <link href="/2022/09/06/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E6%95%91%E8%B5%8E%E2%80%94%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/09/06/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E6%95%91%E8%B5%8E%E2%80%94%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>大家好，我是跟詹姆斯·邦德扮演者同名同颜的肖恩（Sean）<br>前端算法救赎系列是我避免变成一个只会前端的前端的第一步，我希望把自己学习过程中的心得分享出来，也欢迎大家指出不足，共同进步</p><p>二分查找（Binary Search）是我进入算法领域的第一站，这个系列就从这道最简单最质朴，面试必会的二分查找开始。</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>面试官： 给定一个<code>升序</code>数组 nums，数组里只包含整数，在该数组中找到指定值 target，返回其下标值，如果没找到则返回-1</p><p>这还不简单？直接 <code>for</code> 循环遍历啊</p><p>面试官：哈哈，你真聪明，回去等消息吧</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="二分查找是什么"><a href="#二分查找是什么" class="headerlink" title="二分查找是什么"></a>二分查找是什么</h3><p>如字面意思，将一组数据从中间分成两部分，如果中间的数值比目标值小，则对右边那部分进行二分查找搜索目标值；如果中间的数值比目标值大，则对左边的那部分进行二分查找。当然，这么做的前提是这组数据是<strong>升序</strong>的。</p><h3 id="为什么-for-循环不能让面试官满意"><a href="#为什么-for-循环不能让面试官满意" class="headerlink" title="为什么 for 循环不能让面试官满意"></a>为什么 for 循环不能让面试官满意</h3><ul><li>for 循环是步进式的搜索，如果从头部开始搜索，搜索元素在尾部，那么这组数据有多长，我们就要查多少次，它的时间复杂度为 <code>O(n)</code></li><li>而二分搜索利用排序好的数组，每一次查找都将搜索范围减半，如果搜索一个长度为 n 的数组，最坏的情况下是将数组对半到只剩一个元素才找到，即<code>log2n</code>次，时间复杂度为<code>O(logn)</code>，是低于线性的 for 循环的<code>O(n)</code>的</li></ul><h2 id="如何进行二分搜索"><a href="#如何进行二分搜索" class="headerlink" title="如何进行二分搜索"></a>如何进行二分搜索</h2><h3 id="两根指针"><a href="#两根指针" class="headerlink" title="两根指针"></a>两根指针</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> end = nums.<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><h3 id="循环移动指针求两根指针的中点"><a href="#循环移动指针求两根指针的中点" class="headerlink" title="循环移动指针求两根指针的中点"></a>循环移动指针求两根指针的中点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span> (start + <span class="hljs-number">1</span> &lt; end) &#123;<br>  <span class="hljs-keyword">const</span> mid = start + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((end - start) / <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对比中点值和-target-大小缩小区间"><a href="#对比中点值和-target-大小缩小区间" class="headerlink" title="对比中点值和 target 大小缩小区间"></a>对比中点值和 target 大小缩小区间</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span> (start + <span class="hljs-number">1</span> &lt; end) &#123;<br>  <span class="hljs-keyword">const</span> mid = start + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((end - start) / <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>    start = mid;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    right = mid;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断值所在位置"><a href="#判断值所在位置" class="headerlink" title="判断值所在位置"></a>判断值所在位置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (nums[start] === target) <span class="hljs-keyword">return</span> start;<br><span class="hljs-keyword">if</span> (nums[end] === target) <span class="hljs-keyword">return</span> end;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">nums, target</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!nums?.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> end = nums.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">while</span> (start + <span class="hljs-number">1</span> &lt; end) &#123;<br>    <span class="hljs-keyword">const</span> mid = start + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((end - start) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>      start = mid;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      right = mid;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (nums[start] === target) <span class="hljs-keyword">return</span> start;<br>  <span class="hljs-keyword">if</span> (nums[end] === target) <span class="hljs-keyword">return</span> end;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>数据结构与算法</category>
      
      <category>查找</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP三次握手与四次挥手</title>
    <link href="/2022/07/21/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <url>/2022/07/21/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sean</p><p>前言：经典面试题，TCP 建立连接需要经过三次握手，断开连接则需要四次挥手</p><p>前端必会面试题</p></blockquote><h2 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h2><ul><li><code>SYN(synchronous)</code> - 用于初始化一个连接的序列号，建立联机</li><li><code>ack(acknowledgement)</code>- 确认号码</li><li><code>seq(sequence)</code> - 顺序号码</li><li><code>ISN(Initial Sequence Number)</code> - 初始序列号</li><li><code>ACK</code> - 确认，使得确认号有效（握手用）</li><li><code>FIN(finish)</code> - 该报文的发送方已经结束向对方发送数据</li><li><code>MSL</code> - 最长报文寿命，一个 MSL 是 2 分钟</li></ul><h2 id="TCP-的三次握手-（双端建立稳定连接）"><a href="#TCP-的三次握手-（双端建立稳定连接）" class="headerlink" title="TCP 的三次握手 （双端建立稳定连接）"></a>TCP 的三次握手 （双端建立稳定连接）</h2><ol><li>客户端通过<code>SYN</code>报文段发送连接请求 (SYN 标志位为 1，初始序列号 x，和 ACK 标志位为 0)，确定服务端是否开启端口准备连接，状态设置为<code>SYN_SEND</code> （SYN&#x3D;1, seq&#x3D;x）</li><li>服务器如果开着端口并且决定连接，就会返回一个<code>SYN+ACK</code>报文段给客户端（SYN 和 ACK 标志位均为 1），同时确认 ISN 序列号，放到 seq 域里，并将 ack 设置为客户端的 ISN 加 1，状态设置为<code>SYN_RECV</code> （SYN&#x3D;1, Seq&#x3D;y, Ack&#x3D;x+1）</li><li>客户端收到服务器的<code>SYN_RECV</code>报文段，会向服务器发送<code>ACK</code>报文段表示确认（包含了服务器端发来的 ISN 序列号，并且将该 ISN 加 1），此时客户端和服务端都设置为<code>ESTABLISHED</code>状态。状态连接可以开始数据传输了 （SYN&#x3D;1, Seq&#x3D;x+1, Ack&#x3D;y+1）</li></ol><h3 id="为什么是三次"><a href="#为什么是三次" class="headerlink" title="为什么是三次"></a>为什么是三次</h3><ul><li>避免历史连接，例如，客户端发送了建立连接请求，在某些网络节点长时间滞留，一直未收到服务端确认，再次发送请求并收到确认建立连接，数据传输完毕后释放了连接。这时候第一次滞留的请求又成功发送到服务端，服务端同意建立连接，如果没有第三次握手，服务端会一直等待客户端发送数据，浪费资源。</li><li>建立稳定可靠的 TCP 连接，需要确认客户端和服务端双方的接收和发送能力。第一次 SYN 和 Seq 确认客户端的发送能力，第二次 SYN 和 Seq 确认服务端的发送能力，Ack 确认服务端的接收能力，第三次 Ack 确认客户端的接收能力。</li></ul><h3 id="半连接队列"><a href="#半连接队列" class="headerlink" title="半连接队列"></a>半连接队列</h3><p>当第二次握手后服务端处于<code>SYN_RECV</code> 状态，服务端会把请求连接都放在半连接队列中。当第三次握手后，就会放在全连接队列中，当队列满了，就会存在丢包现象。</p><ul><li>第二次握手后如果服务端一直未收到客户端确认，会进行多次重传尝试，超过最大限次后，会将连接信息从半连接队列中删除。</li></ul><h3 id="ISN-是固定的吗？"><a href="#ISN-是固定的吗？" class="headerlink" title="ISN 是固定的吗？"></a>ISN 是固定的吗？</h3><p>ISN（Initial Sequence Number）是随时间变化的，每 4ms 加 1。方式网络中被延迟分组在以后又被传送，而导致某个连接的一方对它做错误的理解。同时 ISN 也会让双方知道建立连接后如何按序列号组装数据，动态可以防止攻击者猜出后续的确认号</p><h3 id="三次握手期间可以携带数据吗"><a href="#三次握手期间可以携带数据吗" class="headerlink" title="三次握手期间可以携带数据吗"></a>三次握手期间可以携带数据吗</h3><p>前两次不可以，防止在报文中夹带大量数据攻击，服务器会花费大量时间和空间来接收这些报文</p><h3 id="SYN-攻击"><a href="#SYN-攻击" class="headerlink" title="SYN 攻击"></a>SYN 攻击</h3><p>一种典型的 DDoS 攻击，伪造大量不存在的 ip 向服务端发起连接请求，因为是伪造的地址，服务端会不停的发送确认请求直至超时，伪造的 SYN 包也会长时间占用半连接队列，导致正常的请求进不来，被废弃，引发网络堵塞，甚至系统瘫痪</p><h2 id="TCP-的四次挥手-（双端关闭-TCP-连接）"><a href="#TCP-的四次挥手-（双端关闭-TCP-连接）" class="headerlink" title="TCP 的四次挥手 （双端关闭 TCP 连接）"></a>TCP 的四次挥手 （双端关闭 TCP 连接）</h2><ol><li>客户端向服务器端发送一个<code>FIN</code>标志位置为 1，当前序列号为 u 的包，准备断开连接，并且进入<code>FIN_WAIT_1</code>状态 （FIN&#x3D;1, seq&#x3D;u）</li><li>服务器端收到 FIN 包，会发送一个确认序号收到序列号为<code>u+1</code>的包，表明自己接受到客户端关闭连接的请求，但还未准备好关闭连接。服务器端进入<code>CLOSE_WAIT</code>状态，客户端进入<code>FIN_WAIT_2</code>状态（ACK&#x3D;1, seq&#x3D;v, ack&#x3D;u+1）</li><li>服务器端发送完剩余数据后，会发送一个自己的<code>FIN</code>包，序列号为<code>u+1</code>。服务器端进入<code>LAST_ACK</code>状态，等待客户端的最后一个<code>ACK</code> （FIN&#x3D;1, ACK&#x3D;1, seq&#x3D;w, ack&#x3D; u+1）</li><li>客户端收到服务器端的关闭请求好，发送最后一个<code>ACK</code>确认包，确认序列号设置为收到序列号加 1。客户端进入<code>TIME_WAIT</code>状态，等待可能出现的要求重传的<code>ACK</code>包。服务器端接受到这个确认包之后就关闭连接，进入<code>CLOSED</code>状态。客户端等待<code>2MSL</code>之后，没有收到服务器端的<code>ACK</code>，就确认服务器端已经关闭，然后自己就关闭进入<code>CLOSED</code>状态 （ACK&#x3D;1, seq&#x3D;u+1, ack&#x3D;w+1）</li></ol><h3 id="为什么不是两次"><a href="#为什么不是两次" class="headerlink" title="为什么不是两次"></a>为什么不是两次</h3><ul><li>只有两次就是客户端说完结束立刻断开不再接受，这样无法确认服务器端是否接受到断开消息，服务器端可能还有消息未发送完</li></ul><h3 id="为什么不是三次"><a href="#为什么不是三次" class="headerlink" title="为什么不是三次"></a>为什么不是三次</h3><ul><li>只有三次情况为服务器端接受到断开消息，需要客户端给出确认断开的回复</li></ul><h3 id="为什么客户端发送最后一个-ACK-确认包后不直接关闭"><a href="#为什么客户端发送最后一个-ACK-确认包后不直接关闭" class="headerlink" title="为什么客户端发送最后一个 ACK 确认包后不直接关闭"></a>为什么客户端发送最后一个 ACK 确认包后不直接关闭</h3><ul><li>客户端还会再等 2MSL 后，才会断开连接进入 closed 状态，这样以防服务端发送的数据包网络延迟滞留，在关闭确认包之后才到达。</li><li>也以防这时候客户端又建立其他连接接受到了之前链接的数据包</li></ul><h3 id="为什么等待-2MSL"><a href="#为什么等待-2MSL" class="headerlink" title="为什么等待 2MSL"></a>为什么等待 2MSL</h3><p>1MSL 确保发起关闭方的最后一个 ACK 报文发送到接收方</p><p>1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
      <category>计算机基础</category>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输入url渲染以及渲染原理</title>
    <link href="/2022/07/18/%E8%BE%93%E5%85%A5url%E6%B8%B2%E6%9F%93%E4%BB%A5%E5%8F%8A%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"/>
    <url>/2022/07/18/%E8%BE%93%E5%85%A5url%E6%B8%B2%E6%9F%93%E4%BB%A5%E5%8F%8A%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sean</p><p>前言：经典面试题，输入一个 url 到浏览器地址栏中直到页面有内容展示过程中发生了什么？</p><p>高级前端必会面试题</p></blockquote><h2 id="URL-的组成"><a href="#URL-的组成" class="headerlink" title="URL 的组成"></a>URL 的组成</h2><p>URL &#x3D; 协议 + 主机 + 端口 + 路径 + 查询参数 + 锚点</p><p>https://seanmr.github.io:8080/20210226/index.html?name=sean#front</p><p><img src="/../images/url.png"></p><h2 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h2><p>通过 DNS 解析域名的实际 IP 地址</p><ul><li>递归查找：浏览器缓存找对应 ip 地址 —&gt; os 系统（例如 windows 系统的<code>host</code>文件）的 DNS 缓存找 —&gt; 路由器的 DNS 缓存找 —&gt; ISP（运营商）的 DNS 缓存找。如果都没有找到：</li><li>迭代查找：根域名服务器 —&gt; com 顶级域名服务器 —&gt; 二级域名服务器</li></ul><p><img src="/../images/dns.png"></p><h2 id="检查缓存"><a href="#检查缓存" class="headerlink" title="检查缓存"></a>检查缓存</h2><ul><li>通过<code>Cache-Control</code>和<code>Expires</code>来检查是否命中强缓存，命中则直接取本地磁盘的 html，不需要发送请求</li><li>如果没有命中强缓存，则会向服务器发起请求（先进行下一步的 TCP 连接），服务器通过<code>ETag</code>和<code>Last-Modify</code>来取服务器确认返回的响应是否被更改（协商缓存），若无更改则返回状态码（304），浏览器取本地缓存</li><li>若强缓存和协商缓存都没有命中则发送网络请求</li></ul><h2 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a>建立 TCP 连接</h2><p><a href="https://seanmr.github.io/2022/07/21/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">三次握手</a></p><h3 id="TSL-加密"><a href="#TSL-加密" class="headerlink" title="TSL 加密"></a>TSL 加密</h3><p>https 还需要经过 TSL 或者 SSL 加密，四次握手</p><h2 id="浏览器发送请求"><a href="#浏览器发送请求" class="headerlink" title="浏览器发送请求"></a>浏览器发送请求</h2><p>待补充</p><h2 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h2><ul><li>服务器可能是<code>server</code>也可能是<code>cdn</code> （内容分发网络，用来加快传输速度，主要用来存储静态文件）</li><li>服务器上可能会通过<code>nginx</code>等设置静态资源代理，将 url 对应的 html 等静态资源返回。nginx 是常用的反向代理服务器</li><li>这一阶段可能会发生服务端渲染，如果网站是博客或者其他需要 seo 友好的页面时。常见方案有：<code>ejs, art-template</code>。基于框架的<code>nuxt.js</code>及<code>next.js</code></li></ul><h2 id="浏览器解析与渲染"><a href="#浏览器解析与渲染" class="headerlink" title="浏览器解析与渲染"></a>浏览器解析与渲染</h2><h3 id="解析-html-与-css"><a href="#解析-html-与-css" class="headerlink" title="解析 html 与 css"></a>解析 html 与 css</h3><p><code>html</code>解析</p><ul><li>浏览器首先将接受到的字节数据（也就是 0 和 1）转换成字符串（也就是我们写的代码），</li><li>然后浏览器会将这些字符串通过词法分析（标记化 tokenization）转换成标记（token，构成代码的最小单位）。例如<code>&lt;a&gt;</code>就会被打上一个标记</li><li>标记化结束后，浏览器会将这些标记转为<code>Node</code>，这些<code>Node</code>根据不同<code>Node</code>之间的联系构建一棵<code>DOM</code>树</li></ul><p><code>css</code>解析</p><ul><li>解析过程与<code>html</code>解析相似，最终递归出<code>CSSOM</code>树</li><li>避免写过于具体的 css 选择器，例如<code>div &gt; a &gt; span</code>，浏览器会从右向左查找，先找到所有 span 标签所在位置，再向上查找有没有 a 标签，符合条件再向上查找有无 div 标签，最终再给完全符合条件的标记设置样式。这样的递归过于复杂</li></ul><p>渲染阻塞</p><ul><li>HTML 和 CSS 解析过程中一定会阻塞渲染，所以要降低一开始渲染的文件的大小，扁平层级，优化选择器。</li><li>JS 解析会阻塞 DOM 构建和渲染，具体表现为解析到<code>script</code>标签，暂停构建<code>DOM</code>，开始下载 JS 文件，并解析执行。再从暂停的地方重新开始构建<code>DOM</code><ul><li>应当将 script 标签写到 body 的最下方，等待 DOM 解析构建渲染完成，再解析执行 JS 脚本</li><li>script 加<code>defer</code>属性，表示 JS 脚本会并行下载，等待 HTML 解析完成后再执行</li><li>script 加<code>async</code>属性，表示这个 JS 脚本没有任何依赖，它的解析和执行是不会阻塞渲染的</li></ul></li></ul><h3 id="回流与重绘"><a href="#回流与重绘" class="headerlink" title="回流与重绘"></a>回流与重绘</h3><p>生成渲染树</p><ul><li>渲染树只会包含需要渲染的节点以及这些节点的信息，<code>display: none</code>的节点则不被包含在渲染树中</li><li>渲染树生成后，浏览器会根据渲染树进行布局，这个过程叫做<code>回流</code>，在屏幕上呈现图层</li></ul><h2 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h2><p><a href="https://seanmr.github.io/2022/07/21/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">四次挥手</a></p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
      <category>计算机基础</category>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript类型和类型转换</title>
    <link href="/2022/07/07/JavaScript%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/07/07/JavaScript%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sean</p><p>前言：精通 JavaScript 数据类型以及数据类型的各种转换</p><p>前端必会面试题</p></blockquote><h2 id="JavaScript-数据类型"><a href="#JavaScript-数据类型" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h2><ul><li>基本类型<ul><li>字符串</li><li>数字</li><li>布尔值</li><li>null</li><li>undefined</li><li>symbol</li><li>bigInt</li></ul></li><li>引用类型<ul><li>Object</li><li>Array</li><li>Date</li><li>Regx</li></ul></li></ul><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><ul><li>可以判断除 null 以外的所有基础类型</li><li><code>typeof null</code> 值为 <code>object</code></li><li>除了函数 <code>typeof 引用类型</code>值为 <code>object</code></li><li><code>typeof 函数</code>值为 <code>function</code></li></ul><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>可以判断所有引用类型</p><ul><li>无法解决 null 的判断问题</li></ul><h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h3><p>可以判断所有数据类型，值为<code>&#39;[object 具体类型]&#39;</code></p><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><ul><li>转换成布尔值<ul><li>number 除了 0，-0，NaN 都为 <code>true</code></li><li>string 除了空串都为 <code>true</code></li><li>undefined, null 为 <code>false</code></li><li>引用类型 <code>true</code></li></ul></li><li>转换成数字<ul><li>字符串 <code>&#39;number&#39; =&gt; number</code> 其他情况 <code>NaN</code></li><li>数组 <code>[] =&gt; 0</code>，<code>[1] =&gt; 1</code>，<code>[1, 2] =&gt; NaN</code></li><li>null <code>0</code></li><li>除了数组的引用类型 <code>NaN</code></li><li>Symbol 抛错</li></ul></li><li>转换成字符串<ul><li>number <code>&#39;number&#39;</code></li><li>布尔，函数，symbol <code>&#39;true&#39;</code></li><li>数组 <code>[1, 2] =&gt; &#39;1, 2&#39;</code></li><li>对象 <code>&#39;[object Object]&#39;</code></li></ul></li></ul><h3 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h3><ul><li>有字符串其他也转换成字符串</li><li>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</li><li><code>+&#39;a&#39; = NaN</code></li><li>除了加法运算，其他运算只要有一方是数字，其他都会被转成数字</li></ul><h3 id="比较"><a href="#比较" class="headerlink" title="==比较"></a><code>==</code>比较</h3><ol><li>首先会判断是否为同类型</li><li>判断是否在对比<code>null</code>和<code>undefined</code>，是则返回<code>true</code></li><li>判断两者是否为字符串和数字，是的话将字符串转换为<code>number</code></li><li>判断一方是否为布尔值，是则将布尔值转换为<code>number</code></li><li>判断一方是否为 <code>object</code>，另一方是否为 <code>string</code>、<code>number</code> 或者 <code>symbol</code>，是则将 <code>object</code> 转换成原始类型</li></ol><ul><li>对象通过<code>toPrimitive</code>转换对象</li><li>字符串通过<code>unicode</code>字符串索引</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
      <category>前端基础</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写Promise</title>
    <link href="/2022/06/18/%E6%89%8B%E5%86%99Promise/"/>
    <url>/2022/06/18/%E6%89%8B%E5%86%99Promise/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sean</p><p>前言：手写具备 A+规范的 Promise</p><p>高级前端必会面试题</p></blockquote><h2 id="1、搭个框架"><a href="#1、搭个框架" class="headerlink" title="1、搭个框架"></a>1、搭个框架</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> handlerProps &#123;<br>  <span class="hljs-attr">onResolve</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>  <span class="hljs-attr">onReject</span>: <span class="hljs-function">(<span class="hljs-params">rej</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">State</span> = <span class="hljs-string">&#x27;pending&#x27;</span> | <span class="hljs-string">&#x27;fullfilled&#x27;</span> | <span class="hljs-string">&#x27;rejected&#x27;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise2</span> &#123;<br>  <span class="hljs-attr">state</span>: <span class="hljs-title class_">State</span> = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>  <span class="hljs-attr">handler</span>: handlerProps = &#123;<br>    <span class="hljs-attr">onResolve</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;&#125;,<br>    <span class="hljs-attr">onReject</span>: <span class="hljs-function">(<span class="hljs-params">rej</span>) =&gt;</span> &#123;&#125;,<br>  &#125;;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Promise必须传入一个函数&#x27;</span>);<br>    <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">resolve</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reject</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-params">result</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&#x27;fullfilled&#x27;</span>;<br>    <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">handler</span>.<span class="hljs-property">onResolve</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">handler</span>.<span class="hljs-title function_">onResolve</span>(result);<br>    &#125;);<br>  &#125;<br>  <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>    <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">handler</span>.<span class="hljs-property">onReject</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">handler</span>.<span class="hljs-title function_">onReject</span>(reason);<br>    &#125;);<br>  &#125;<br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onResolve?, onReject?</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onResolve === <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">handler</span>.<span class="hljs-property">onResolve</span> = onResolve;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onReject === <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">handler</span>.<span class="hljs-property">onReject</span> = onReject;<br>  &#125;<br>  <span class="hljs-keyword">catch</span>(onReject?) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, onReject);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><strong>没有 then 链</strong></li><li>then 和 catch 里的函数不会被调用</li><li>函数里面抛错，then 的 reject 捕获不了</li></ul><h3 id="改写-nextTick"><a href="#改写-nextTick" class="headerlink" title="改写 nextTick"></a>改写 nextTick</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">nextTick</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">if</span> (process !== <span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-keyword">typeof</span> process.<span class="hljs-property">nextTick</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> process.<span class="hljs-title function_">nextTick</span>(fn);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">var</span> counter = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">var</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(fn);<br>    <span class="hljs-keyword">var</span> textNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-title class_">String</span>(counter));<br><br>    observer.<span class="hljs-title function_">observe</span>(textNode, &#123;<br>      <span class="hljs-attr">characterData</span>: <span class="hljs-literal">true</span>,<br>    &#125;);<br><br>    counter = counter + <span class="hljs-number">1</span>;<br>    textNode.<span class="hljs-property">data</span> = <span class="hljs-title class_">String</span>(counter);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="维护一个数组，then-返回值是一个-promise"><a href="#维护一个数组，then-返回值是一个-promise" class="headerlink" title="维护一个数组，then 返回值是一个 promise"></a>维护一个数组，then 返回值是一个 promise</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> handlerProps &#123;<br>  <span class="hljs-attr">onResolve</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>  <span class="hljs-attr">onReject</span>: <span class="hljs-function">(<span class="hljs-params">rej</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>  <span class="hljs-attr">handleNext</span>: _Promise;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_Promise</span> &#123;<br>  <span class="hljs-attr">callbacks</span>: handlerProps[] = [];<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="then-改写"><a href="#then-改写" class="headerlink" title="then 改写"></a>then 改写</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolve?, onReject?</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">handler</span>: handlerProps = &#123;<br>    <span class="hljs-attr">onResolve</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;&#125;,<br>    <span class="hljs-attr">onReject</span>: <span class="hljs-function">(<span class="hljs-params">rej</span>) =&gt;</span> &#123;&#125;,<br>    <span class="hljs-attr">handleNext</span>: <span class="hljs-keyword">new</span> <span class="hljs-title function_">_Promise</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;),<br>  &#125;;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onResolve === <span class="hljs-string">&#x27;function&#x27;</span>) handler.<span class="hljs-property">onResolve</span> = onResolve;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onReject === <span class="hljs-string">&#x27;function&#x27;</span>) handler.<span class="hljs-property">onReject</span> = onReject;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">push</span>(handler);<br>  <span class="hljs-keyword">return</span> handler.<span class="hljs-property">handleNext</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="resolve-和-reject-里的调用逻辑"><a href="#resolve-和-reject-里的调用逻辑" class="headerlink" title="resolve 和 reject 里的调用逻辑"></a>resolve 和 reject 里的调用逻辑</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">resolve</span>(<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&#x27;fullfilled&#x27;</span>;<br>  <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (cb.<span class="hljs-property">onResolve</span>) &#123;<br>        <span class="hljs-keyword">const</span> x = cb.<span class="hljs-title function_">onResolve</span>(result);<br>        <span class="hljs-comment">// 执行next</span><br>        cb.<span class="hljs-property">handleNext</span>.<span class="hljs-title function_">resolve</span>(x);<br>      &#125;<br>    &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>rejct 同样需要改写</p><h2 id="Promise-Api"><a href="#Promise-Api" class="headerlink" title="Promise Api"></a>Promise Api</h2><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise2</span>.<span class="hljs-property">resolve</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise2</span>) &#123;<br>    <span class="hljs-keyword">return</span> value;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> &amp;&amp; <span class="hljs-string">&#x27;then&#x27;</span> <span class="hljs-keyword">in</span> value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise2</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>      value.<span class="hljs-title function_">then</span>(res, rej);<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise2</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">res</span>(value);<br>    &#125;);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise2</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;&#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise2</span>.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise2</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">reject</span>(reason);<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise2</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(promises)) <span class="hljs-keyword">throw</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;not iterable&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (!promises.<span class="hljs-property">length</span>) <span class="hljs-title class_">Promise2</span>.<span class="hljs-title function_">resolve</span>(promises);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise2</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">p, index</span>) =&gt;</span> &#123;<br>      p.<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          result[index] = value;<br>          count += <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">if</span> (count === promises.<span class="hljs-property">length</span>) <span class="hljs-title function_">resolve</span>(result);<br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>          <span class="hljs-title function_">reject</span>(reason);<br>        &#125;<br>      );<br>    &#125;);<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise2</span>.<span class="hljs-property">any</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(promises)) <span class="hljs-keyword">throw</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;not iterable&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (!promises.<span class="hljs-property">length</span>) <span class="hljs-title class_">Promise2</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;All promises were rejected&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise2</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> error = [];<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">p, index</span>) =&gt;</span> &#123;<br>      p.<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          <span class="hljs-title function_">resolve</span>(value);<br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>          result[index] = reason;<br>          count += <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">if</span> (count === promises.<span class="hljs-property">length</span>) <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;All promises were rejected&#x27;</span>);<br>        &#125;<br>      );<br>    &#125;);<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise2</span>.<span class="hljs-property">race</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(promises)) <span class="hljs-keyword">throw</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;not iterable&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (!promises.<span class="hljs-property">length</span>) <span class="hljs-title class_">Promise2</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;All promises were rejected&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise2</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">p, index</span>) =&gt;</span> &#123;<br>      p.<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          <span class="hljs-title function_">resolve</span>(value);<br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>          <span class="hljs-title function_">reject</span>(reason);<br>        &#125;<br>      );<br>    &#125;);<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise2</span>.<span class="hljs-property">allSettled</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(promises)) <span class="hljs-keyword">throw</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;not iterable&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (!promises.<span class="hljs-property">length</span>) <span class="hljs-title class_">Promise2</span>.<span class="hljs-title function_">resolve</span>(promises);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise2</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">p, index</span>) =&gt;</span> &#123;<br>      p.<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          result[index] = &#123;<br>            value,<br>            <span class="hljs-attr">state</span>: <span class="hljs-string">&#x27;fullfilled&#x27;</span>,<br>          &#125;;<br>          count += <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">if</span> (count === promises.<span class="hljs-property">length</span>) <span class="hljs-title function_">resolve</span>(result);<br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>          result[index] = &#123;<br>            reason,<br>            <span class="hljs-attr">state</span>: <span class="hljs-string">&#x27;rejected&#x27;</span>,<br>          &#125;;<br>          count += <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">if</span> (count === promises.<span class="hljs-property">length</span>) <span class="hljs-title function_">resolve</span>(result);<br>        &#125;<br>      );<br>    &#125;);<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
      <category>前端基础</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用hexo搭建个人博客</title>
    <link href="/2022/06/13/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/06/13/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sean</p><p>前言 ：本文为如何搭建一个 hexo 静态博客，步骤非常细致，可以按照流程一步一步创建。文章也涵盖了一些创建博客时需要注意的问题以及我踩过的坑。 另外在配置环境和安装依赖时也可能会遇到很多问题，百度谷歌上对同类问题已有很多解答，本文不再赘述。</p></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>博客部署到远端时创建的 github 仓库名格式为<code>username.github.io</code>，<strong>且 username 一定要与 github 用户名一致。</strong></li><li>windows 操作系统要使用 git bash，cmd 无法执行一些终端命令</li></ol><h2 id="1-初建博客"><a href="#1-初建博客" class="headerlink" title="1. 初建博客"></a>1. 初建博客</h2><h3 id="1-1-配置环境、安装依赖"><a href="#1-1-配置环境、安装依赖" class="headerlink" title="1.1 配置环境、安装依赖"></a>1.1 配置环境、安装依赖</h3><ul><li>安装 node</li><li>安装 git</li><li>安装 hexo，在终端中执行<code>npm i -g hexo-cli</code>全局安装</li></ul><h3 id="1-2-创建博客"><a href="#1-2-创建博客" class="headerlink" title="1.2 创建博客"></a>1.2 创建博客</h3><ul><li><p>进入到想要放置博客文件夹的位置，例如<code>cd D://</code></p></li><li><p>创建博客文件夹，<code>mkdir myBlog</code></p></li><li><p>进入 blog 文件夹，<code>cd myBlog</code></p></li><li><p>初始化博客，<code>hexo init</code></p></li><li><p>新建文章，<code>hexo new &quot;我的第一篇文章&quot;</code></p></li><li><p>使用 markdown 格式编辑这篇文章</p></li><li><p>生成博客，<code>hexo g</code></p></li><li><p>本地预览博客，<code>hexo s</code></p></li><li><p>清除旧数据，<code>hexo clean</code></p></li></ul><h2 id="2-部署博客到远端"><a href="#2-部署博客到远端" class="headerlink" title="2. 部署博客到远端"></a>2. 部署博客到远端</h2><ul><li><p>创建一个 github 仓库，仓库名格式为<code>username.github.io</code>，<strong>且 username 一定要与 github 用户名一致</strong>。</p></li><li><p>安装依赖<code>npm i --save hexo-deployer-git</code></p></li><li><p>配置 blog 文件夹里的<code>_config.yml</code>文件</p><p class="note note-warning">注意！type, repo, branch后面一定要有一个空格，否则会失败！</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>    <span class="hljs-attr">repo:</span> <span class="hljs-string">你的github仓库地址</span><br>    <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure></li><li><p>清除旧数据，<code>hexo clean</code></p></li><li><p>生成博客，<code>hexo g</code></p></li><li><p>部署到远端 <code>hexo d</code></p></li><li><p>访问博客地址在线预览，网址为<code>你的用户名.github.io</code></p></li></ul><h2 id="3-更换主题"><a href="#3-更换主题" class="headerlink" title="3. 更换主题"></a>3. 更换主题</h2><ul><li><p>在 github 上搜索<code>hexo-theme</code>找到喜欢的主题，推荐 yilla, fluid-dev 等</p></li><li><p>克隆主题。<code>git clone 目标主题的github地址 themes/xxx(主题的名字)</code></p></li><li><p>配置 blog 文件夹里的<code>_config.yml</code>文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><span class="hljs-attr">themes:</span> <span class="hljs-string">你克隆的主题</span><br></code></pre></td></tr></table></figure></li><li><p>清除旧数据，<code>hexo clean</code></p></li><li><p>生成博客，<code>hexo g</code></p></li><li><p>部署到远端 <code>hexo d</code></p></li><li><p>访问博客地址在线预览，网址为<code>你的用户名.github.io</code></p></li><li></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1Yb411a7ty">手把手教你从 0 开始搭建自己的个人博客 |无坑版视频教程| hexo</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>防抖和节流</title>
    <link href="/2022/06/13/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <url>/2022/06/13/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sean</p><p>前言：防抖和节流是前端开发中重要的两个概念，但是其概念与其名称一样，没有浅显易懂。防抖和节流是两个不同的功能，都用于限制用户的频繁操作和资源请求，减轻服务器的压力，是前端开发中重要的性能优化方法。下面就让我们探究一下防抖和节流吧。</p></blockquote><h1 id="1-防抖（debounce）"><a href="#1-防抖（debounce）" class="headerlink" title="1. 防抖（debounce）"></a>1. 防抖（debounce）</h1><h2 id="1-1-什么是防抖"><a href="#1-1-什么是防抖" class="headerlink" title="1.1 什么是防抖"></a>1.1 什么是防抖</h2><p>让我们用一个例子来认识防抖：</p><p class="note note-info"><strong>需求</strong> <br> 用户在搜索框中输入内容之后，在下拉框中显示输入内容相关的信息</p><p>那么，很显然，这需要获取用户输入的字符，然后以该字符向服务器发送请求，服务器返回与该字符相关的信息。</p><p><strong>但是，我们需要在用户每输入一个字符就发送一次请求吗？</strong>这显然是不合理的，如果用户数量大，那么服务器将不堪重负。</p><p>我们就需要一点点优化，在用户输入一个字符的未来一段时间内，只要用户持续输入内容，就不发送请求。这时候就需要<strong>“防抖”</strong>，即在这规定的时间内，只有用户持续输入内容，<strong>发送请求的行为就会被打断，规定时间需要重新计时</strong>。这就像是游戏中的“吟唱读条“，在吟唱过程中如果受到了打断，吟唱则需要重头开始。</p><h2 id="1-2-如何实现防抖"><a href="#1-2-如何实现防抖" class="headerlink" title="1.2 如何实现防抖"></a>1.2 如何实现防抖</h2><p>那么如何实现防抖呢？刚刚提到了计时的概念，那很显然需要用到<strong>定时器</strong>。让我们直接看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 闭包返回函数</span><br>    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 保存this</span><br>    timer &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timer); <span class="hljs-comment">// 清除定时器</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 设置定时器</span><br>      func.<span class="hljs-title function_">call</span>(context, ...args); <span class="hljs-comment">// 绑定this指向和传参</span><br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li><p>首先，我们需要为防抖函数传入要执行的函数并设定一个延迟时间。并且用<strong>闭包</strong>的形式将里面的被定时器包裹的函数返回。这是因为我们触发事件需要的是这个内部函数，而不是外面的防抖函数。</p></li><li><p>设置定时器，并将执行函数放进去。为了达到防抖效果，需要在执行函数前<strong>消除定时器</strong>，这样在用户每次执行事件时，定时器就会重新计时。</p></li><li><p>考虑定时器内部<strong>this 指向</strong>问题，需要在外部用一个变量保存 this，在定时器内部用 call 绑定。</p></li><li><p>考虑执行函数的<strong>参数传入</strong>问题。使用剩余参数在 call 绑定 this 指向时一并传入。</p></li></ol><h2 id="1-3-第一次执行"><a href="#1-3-第一次执行" class="headerlink" title="1.3 第一次执行"></a>1.3 第一次执行</h2><p>以上就是基本的防抖函数了，但是它有一个问题，那就是在用户第一次执行事件时，它就会起到一个“防抖”的效果，这在一些场合是我们不希望看见的。于是，我们需要考虑一下如何让函数在第一次事件中能够立刻执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debouceImme</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">const</span> callNow = !timer;<br>    timer &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timer);<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      timer = <span class="hljs-literal">null</span>;<br>    &#125;, delay);<br>    callNow &amp;&amp; func.<span class="hljs-title function_">call</span>(context, ...args);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ul><li>使用了一个<code>callNow</code>限制了函数的执行，只有当 timer 被清除，<code>callNow</code>才为真，函数才执行。</li><li>而定时器的作用缺变成了将自身清除，而不是限制函数的执行。这样与<code>callNow</code>结合后，在计时器计时期间，<code>callNow</code>始终不为真，函数就无法执行，起到了防抖的作用</li><li>而第一次执行时，timer 被定义成 null，所以函数可以直接执行。</li></ul><h2 id="1-4-封装"><a href="#1-4-封装" class="headerlink" title="1.4 封装"></a>1.4 封装</h2><p>将以上两种情况都考虑并封装起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay, immediate</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>    timer &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timer);<br>    <span class="hljs-keyword">if</span> (immediate) &#123;<br>      <span class="hljs-keyword">let</span> callNow = !timer;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;, delay);<br>      callNow &amp;&amp; func.<span class="hljs-title function_">call</span>(context, ...args);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        func.<span class="hljs-title function_">call</span>(context, ...args);<br>      &#125;, delay);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-节流（throttle）"><a href="#2-节流（throttle）" class="headerlink" title="2. 节流（throttle）"></a>2. 节流（throttle）</h1><h2 id="2-1-什么是节流"><a href="#2-1-什么是节流" class="headerlink" title="2.1 什么是节流"></a>2.1 什么是节流</h2><p>理解了防抖，拿什么是节流呢？还是用一个例子：</p><p class="note note-info"><strong>需求</strong> <br> 用户使用手机验证码登录时，请求一次验证码之后要60s之后才能再次点击请求，考虑到一些需求，不能将按钮直接设置为disabled</p><p>同理，我们还是可以使用定时器来解决这个需求，<strong>即定时器只要在计时，这个函数就不会进入执行</strong>。不管用户在如何点击按钮也不会触发事件。这就像是游戏中技能的“冷却时间”，一个技能在释放完毕之后，要经过一段时间才能再次释放。</p><h2 id="2-2-如何实现节流"><a href="#2-2-如何实现节流" class="headerlink" title="2.2 如何实现节流"></a>2.2 如何实现节流</h2><p>直接上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, delay</span>)&#123;<br>  <span class="hljs-keyword">let</span> timer;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">if</span> (timer) <span class="hljs-keyword">return</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>      func.<span class="hljs-title function_">call</span>(context, ...args)<br>      timer = <span class="hljs-literal">null</span>；<br>    &#125;, delay)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ul><li>相对于上面的防抖，节流就很好理解了。在设置完定时器之后，只要这个定时器还在计时，重复执行这个时间都会触发<code>if(timer) return</code>直接返回。</li></ul><h2 id="2-3-第一次执行"><a href="#2-3-第一次执行" class="headerlink" title="2.3 第一次执行"></a>2.3 第一次执行</h2><p>同样，上面的节流函数在第一次执行事件就直接进入了计时。为了让第一次就能直接触发事件，我们需要使用新的思路来重新这个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttleimme</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> pre = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<br>    <span class="hljs-keyword">if</span>(now - pre &gt; delay) &#123;<br>      <span class="hljs-title function_">func</span>(...args)<br>      pre = now<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>这里直接将定时器替换成简单的时间减算。</p><ul><li>首先第一次执行时，<code>now - pre</code>肯定大于延迟的值，则必定能进入内部执行函数</li><li>执行完函数后，将刚刚设置的<code>now</code>时间赋值给了<code>pre</code>，下次再点击时，又重新了设置<code>now</code>，新的<code>now</code>减去旧的<code>now</code>的到的时间就是上一次执行完时间后所过的时间，如果不够设置的间隔时间，是无法再次触发事件的。</li></ul><h2 id="2-4-封装"><a href="#2-4-封装" class="headerlink" title="2.4 封装"></a>2.4 封装</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, delay, imme</span>) &#123;<br>  <span class="hljs-keyword">if</span> (imme) &#123;<br>    <span class="hljs-keyword">let</span> pre = <span class="hljs-number">0</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">let</span> timer;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">if</span> (imme) &#123;<br>      <span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>      <span class="hljs-keyword">if</span> (pre - now &gt; delay) &#123;<br>        <span class="hljs-title function_">func</span>(...args);<br>        pre = now;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        func.<span class="hljs-title function_">call</span>(context, ...args);<br>      &#125;, delay);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li><p>当使用防抖函数时，内部的执行函数不能够加<code>( )</code>,否则函数会立刻执行</p></li><li><p>如果要传入参数，应当使用<code>debounce(func.bind(this, ...args), delay)</code></p></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://juejin.cn/post/6844903651278848014#heading-0">函数防抖和节流</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
      <category>JavaScript</category>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何解决跨域问题</title>
    <link href="/2022/06/08/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <url>/2022/06/08/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sean</p><p>前言 ：为什么有跨域问题？</p><p>当客户端向服务器端请求数据的时候，如果两者不同源，即<strong>协议号，域名或者端口号有任一不一样</strong>，则<strong>浏览器</strong>为了安全起见将会拦截服务器端响应的数据。这就是同源政策。而 JSONP 则是一种打破同源政策的方法。</p></blockquote><h1 id="1-什么是-JSONP"><a href="#1-什么是-JSONP" class="headerlink" title="1. 什么是 JSONP"></a>1. 什么是 JSONP</h1><p>JSONP 是 “JSON with padding” 的简写，是在 Web 服务上流行的一种 JSON 变体。</p><p>JSONP 利用<code>&lt;script&gt;</code>标签没有跨域限制的漏洞，网页可以获得其他来源动态产生的 JSON 数据。后端将数据进行相应的转化就能绕开浏览器的同源政策，将数据发送给前端。这也意味着使用 JSONP 需要前端和后端共同支持。</p><h1 id="2-如何使用-JSONP"><a href="#2-如何使用-JSONP" class="headerlink" title="2. 如何使用 JSONP"></a>2. 如何使用 JSONP</h1><h2 id="2-1-实现流程"><a href="#2-1-实现流程" class="headerlink" title="2.1 实现流程"></a>2.1 实现流程</h2><ul><li>声明一个回调函数，该函数将作为请求参数和接受处理数据的重要工具。函数的形参为要获取目标数据。</li><li>动态创建一个<code>script</code>标签插入文本中。把跨域的 API 几口写在 src 属性上，并且将在后面拼接上<code>?callback=回调函数</code>的参数。</li><li>服务器端收到请求后，把传进来的函数名和他需要的数据拼接成一个字符串</li><li>最后服务器把准备的数据返回给客户端，客户端还是使用之前声明的回调函数对返回的数据进行操作。</li></ul><h2 id="2-2-封装一个-JSONP"><a href="#2-2-封装一个-JSONP" class="headerlink" title="2.2 封装一个 JSONP"></a>2.2 封装一个 JSONP</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* index.html */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp</span>(<span class="hljs-params">&#123; url, params, callback &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">creatElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>    <span class="hljs-variable language_">window</span>[callback] = <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>      <span class="hljs-title function_">resolve</span>(data);<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(script);<br>    &#125;;<br>    params = &#123; ...params, callback &#125;;<br>    <span class="hljs-keyword">let</span> arrs = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> parmas) &#123;<br>      arrs.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>`</span>);<br>    &#125;<br>    script.<span class="hljs-property">src</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;arrs.join(<span class="hljs-string">&#x27;&amp;&#x27;</span>)&#125;</span>`</span>;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);<br>  &#125;);<br>&#125;<br><span class="hljs-title function_">jsonp</span>(&#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://www.xxxxx.com:3000/name&#x27;</span>,<br>  <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;,<br>  <span class="hljs-attr">callback</span>: <span class="hljs-string">&#x27;show&#x27;</span>,<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="2-2-服务器端实现"><a href="#2-2-服务器端实现" class="headerlink" title="2.2 服务器端实现"></a>2.2 服务器端实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">var</span> urllib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>);<br><span class="hljs-keyword">var</span> port = <span class="hljs-number">8080</span>;<br><span class="hljs-keyword">var</span> data = &#123; <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;world&#x27;</span> &#125;;<br>http<br>  .<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>    <span class="hljs-keyword">var</span> params = urllib.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span> (params.<span class="hljs-property">query</span>.<span class="hljs-property">callback</span>) &#123;<br>      <span class="hljs-comment">// jsonp</span><br>      <span class="hljs-keyword">var</span> str = params.<span class="hljs-property">query</span>.<span class="hljs-property">callback</span> + <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>      res.<span class="hljs-title function_">end</span>(str);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res.<span class="hljs-title function_">end</span>();<br>    &#125;<br>  &#125;)<br>  .<span class="hljs-title function_">listen</span>(port, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;jsonp server is on&#x27;</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure><h1 id="3-为什么要使用-JSONP"><a href="#3-为什么要使用-JSONP" class="headerlink" title="3. 为什么要使用 JSONP"></a>3. 为什么要使用 JSONP</h1><ul><li><p><strong>简单易用</strong>，解决了主流浏览器跨域数据访问的问题</p></li><li><p><strong>兼容性好</strong>，支持 IE9 以下浏览器</p></li></ul><h1 id="4-JSONP-有什么缺点"><a href="#4-JSONP-有什么缺点" class="headerlink" title="4. JSONP 有什么缺点"></a>4. JSONP 有什么缺点</h1><ul><li>JSONP 仅支持 get 方法</li><li>安全系数不高，容易遭受 XSS 攻击</li><li>不好确定 JSONP 是否请求失败。开发者经常需要使用计时器来确认请求响应时间并决定是否放弃等待响应。但即使如此还是不准确，因为不同用户网络连接速度和带宽是不一样的</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://segmentfault.com/a/1190000007665361">jsonp 的原理与实现</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://juejin.cn/post/6844903767226351623">九种跨域方式实现原理 (完整版)</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
      <category>前端网络</category>
      
      <category>跨域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络安全-XSS &amp; CSRF</title>
    <link href="/2022/06/07/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-XSS-CSRF/"/>
    <url>/2022/06/07/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-XSS-CSRF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sean</p><p>前言 ：XSS 和 CSRF 是常见的网络安全问题，忽视它们可能为应用带来巨大的打击和损失。其中 XSS 名声在外，通常都会采取各种措施进行防护。而 CSRF 却经常被忽视，被认为攻击性没有 XSS 大。但两者可能造成的后果都是严重的。</p></blockquote><h1 id="1-Cross-Site-Scripting"><a href="#1-Cross-Site-Scripting" class="headerlink" title="1. Cross Site Scripting"></a>1. Cross Site Scripting</h1><h2 id="1-1-XSS-是什么"><a href="#1-1-XSS-是什么" class="headerlink" title="1.1 XSS 是什么"></a>1.1 XSS 是什么</h2><p>XSS 攻击是<strong>跨站脚本攻击</strong>。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户信息，比如 cookie 等。这是因为网站没有对恶意代码进行过滤，与正常代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的。</p><h2 id="1-2-XSS-有哪些类型"><a href="#1-2-XSS-有哪些类型" class="headerlink" title="1.2 XSS 有哪些类型"></a>1.2 XSS 有哪些类型</h2><ul><li><strong>存储型（服务器）</strong>，恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给用户，从而导致恶意代码执行</li><li><strong>反射性（服务器）</strong>，攻击者构建了特殊的 URL，当服务器接受到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致恶意代码执行</li><li><strong>DOM 型（浏览器）</strong>，攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行</li></ul><h2 id="1-3-如何预防-XSS"><a href="#1-3-如何预防-XSS" class="headerlink" title="1.3 如何预防 XSS"></a>1.3 如何预防 XSS</h2><h3 id="1-3-1-恶意代码提交时过滤代码"><a href="#1-3-1-恶意代码提交时过滤代码" class="headerlink" title="1.3.1 恶意代码提交时过滤代码"></a>1.3.1 <strong>恶意代码提交时过滤代码</strong></h3><ul><li><p>检测输入的信息，进行前端过滤和后端过滤</p><p class="note note-danger"><strong>不推荐</strong><br>    可能会引起乱码等意外的情况</p></li><li><p>数据存入数据库中时进行转义处理。比如把<code>&amp; &lt; &gt; &quot; &#39; /</code> 等字符转义掉</p><p class="note note-primary"><strong>推荐-服务端</strong><br>    对于转义CSS内联样式，内敛JS，内联JSON等需要额外且复杂的转义策略</p></li></ul><h3 id="1-3-2-浏览器执行恶意代码时方案"><a href="#1-3-2-浏览器执行恶意代码时方案" class="headerlink" title="1.3.2 浏览器执行恶意代码时方案"></a>1.3.2 <strong>浏览器执行恶意代码时方案</strong></h3><ul><li><p>纯前端渲染。</p><ul><li>先让浏览器加载一个静态 HTML，此 HTML 中不包含任何跟业务相关数据。</li><li>然后浏览器执行 HTML 的 js 脚本。</li><li>JS 通过 ajax 加载业务数据，调用 DOM API 更新到页面上。在纯前端渲染中，会明确告诉浏览器，下面要设置的内容)是文本<code>(.innerText)</code>还是属性<code>(.setAttribute)</code>还是要是<code>(.style)</code>。这样浏览器不会被轻易欺骗。</li></ul><p class="note note-primary"><strong>推荐-浏览器</strong><br>    简单设置无法防御DOM型XSS，需要使用.textContent, vue避免使用v-html等</p></li><li><p>白名单</p></li><li><p>限制输入内容长度。可以增加 XSS 攻击难度，但是没有从根本上解决问题<strong>（推荐）</strong></p></li><li><p>HTTP-only Cookie：禁止 JS 读取某些敏感 Cookie，攻击者完成 XSS 注入之后也无法获取 cookie<strong>（推荐）</strong></p></li><li><p>验证码：防止脚本冒充用户提交危险操作</p></li></ul><h1 id="2-Cross-Site-Request-Forgery"><a href="#2-Cross-Site-Request-Forgery" class="headerlink" title="2. Cross Site Request Forgery"></a>2. Cross Site Request Forgery</h1><h2 id="2-1-CSRF-是什么"><a href="#2-1-CSRF-是什么" class="headerlink" title="2.1 CSRF 是什么"></a>2.1 CSRF 是什么</h2><p>CSRF 指跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器进行一些操作。这是利用了 cookie 会在同源请求中携带发送给服务器的特点，以实现用户冒充</p><h2 id="2-2-CSRF-有哪些类型"><a href="#2-2-CSRF-有哪些类型" class="headerlink" title="2.2 CSRF 有哪些类型"></a>2.2 CSRF 有哪些类型</h2><ul><li><strong>get 型</strong>，比如一个 img 标签里构建了一个请求</li><li><strong>post 型</strong>，隐藏的表单，用户进入页面的时候自动提交</li><li><strong>链接型</strong>，诱导用户点击一个链接，该链接会发送请求</li></ul><h2 id="2-3-如何预防-CSRF"><a href="#2-3-如何预防-CSRF" class="headerlink" title="2.3 如何预防 CSRF"></a>2.3 如何预防 CSRF</h2><h3 id="2-3-1-同源检测"><a href="#2-3-1-同源检测" class="headerlink" title="2.3.1 同源检测"></a>2.3.1 <strong>同源检测</strong></h3><p>使用 Origin Header 或者 Referer Header 确定源域名。</p><ul><li>O：大部分请求的 Header 中会携带 Origin 字段，如果存在即为同域。但也存在两种以外情况（IE11 同源政策，302 重定向）。</li><li>R：验证 HTTP 头里的 Referer 字段（其中包括了请求来源地址）</li></ul><h3 id="2-3-2-CSRF-Token-验证"><a href="#2-3-2-CSRF-Token-验证" class="headerlink" title="2.3.2 CSRF Token 验证"></a>2.3.2 <strong>CSRF Token 验证</strong></h3><p>使用 Token 进行身份验证，这样 CSRF 攻击无法获取，也就冒充不了。需要注意的是，Token 是可以放在 cookie 中的，为防止 CSRF，就不能放在 cookie 中了，应当放在 session 中。</p><p class="note note-primary"><strong>推荐</strong><br>    安全性高，但是繁琐且消耗资源大。使用Token对单服务器在大流量的情况压力非常大。并且在会话中存储Token非常繁琐，而且不能在通用的拦截上统一处理所有的接口。</p><h3 id="2-3-3-双重-cookie-验证"><a href="#2-3-3-双重-cookie-验证" class="headerlink" title="2.3.3 双重 cookie 验证"></a>2.3.3 <strong>双重 cookie 验证</strong></h3><p>在用户访问网站页面时，</p><ul><li>想请求域名注入一个 cookie，内容为随机字符串</li><li>在前端向后端发起请求时，取出 cookie，并添加到 URL 的参数中</li><li>后端接口验证 Cookie 中的字段与 URL 参数中的字段是否一致，不一致则拒绝。</li></ul><p class="note note-primary"><strong>推荐</strong><br>    但是在大型网站上安全性没有Token高</p><h3 id="2-3-4-使用samesite-cookie"><a href="#2-3-4-使用samesite-cookie" class="headerlink" title="2.3.4 使用samesite cookie"></a>2.3.4 使用<code>samesite cookie</code></h3><p>限制 cookie 不被第三方使用。将 samesite 设为 strict，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。将其设置为 Lax，如果是个 GET 请求，则这个 cookie 可以作为第三方 cookie。</p><p class="note note-primary"><strong>推荐</strong><br>    但不支持子域，所以子域没有办法与主域共享登录信息</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://juejin.cn/post/6844903685122703367#heading-29">前端安全系列（一）：如何防止 XSS 攻击？</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://juejin.cn/post/6844903689702866952#heading-32">前端安全系列之二：如何防止 CSRF 攻击？</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
